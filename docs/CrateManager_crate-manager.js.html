<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>CrateManager/crate-manager.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <li class="nav-link nav-home-link"><a href="index.html">Home</a></li><li class="nav-heading">Classes</li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="CrateManager.html">CrateManager</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="CrateManager.html#__normaliseContext">__normaliseContext</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="CrateManager.html#addBlankNode">addBlankNode</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="CrateManager.html#addEntity">addEntity</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="CrateManager.html#addFile">addFile</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="CrateManager.html#addFileOrFolder">addFileOrFolder</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="CrateManager.html#addFolder">addFolder</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="CrateManager.html#deleteAllProperties">deleteAllProperties</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="CrateManager.html#deleteEntity">deleteEntity</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="CrateManager.html#deleteProperty">deleteProperty</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="CrateManager.html#exportCrate">exportCrate</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="CrateManager.html#exportEntityTemplate">exportEntityTemplate</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="CrateManager.html#flatten">flatten</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="CrateManager.html#getContext">getContext</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="CrateManager.html#getEntities">getEntities</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="CrateManager.html#getEntity">getEntity</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="CrateManager.html#getEntityTypes">getEntityTypes</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="CrateManager.html#getErrors">getErrors</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="CrateManager.html#getRootDataset">getRootDataset</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="CrateManager.html#getWarnings">getWarnings</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="CrateManager.html#ingestAndLink">ingestAndLink</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="CrateManager.html#linkEntity">linkEntity</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="CrateManager.html#locateEntity">locateEntity</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="CrateManager.html#purgeUnlinkedEntities">purgeUnlinkedEntities</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="CrateManager.html#resolveLinkedEntityAssociations">resolveLinkedEntityAssociations</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="CrateManager.html#setContext">setContext</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="CrateManager.html#setProfileManager">setProfileManager</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="CrateManager.html#setProperty">setProperty</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="CrateManager.html#unlinkEntity">unlinkEntity</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="CrateManager.html#updateProperty">updateProperty</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="EditorState.html">EditorState</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EditorState.html#back">back</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EditorState.html#deleteFromState">deleteFromState</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EditorState.html#forward">forward</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EditorState.html#latest">latest</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EditorState.html#push">push</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EditorState.html#replaceId">replaceId</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EditorState.html#reset">reset</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EditorState.html#update">update</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="ProfileManager.html">ProfileManager</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="ProfileManager.html#getAllInputs">getAllInputs</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="ProfileManager.html#getClasses">getClasses</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="ProfileManager.html#getEntityTypeHierarchy">getEntityTypeHierarchy</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="ProfileManager.html#getInputsFromProfile">getInputsFromProfile</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="ProfileManager.html#getLayout">getLayout</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="ProfileManager.html#getPropertyAssociations">getPropertyAssociations</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="ProfileManager.html#getPropertyDefinition">getPropertyDefinition</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="ProfileManager.html#getTypeDefinition">getTypeDefinition</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="ProfileManager.html#getTypeLabel">getTypeLabel</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="ProfileManager.html#mapTypeHierarchies">mapTypeHierarchies</a></span></li><li class="nav-heading"><a href="global.html">Globals</a></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#isURL">isURL</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#mintNewCrate">mintNewCrate</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#normalise">normalise</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#normaliseEntityType">normaliseEntityType</a></span></li>
</nav>

<div id="main">
    
    <h1 class="page-title">CrateManager/crate-manager.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import isArray from "lodash-es/isArray.js";
import isNumber from "lodash-es/isNumber.js";
import isBoolean from "lodash-es/isBoolean.js";
import isString from "lodash-es/isString.js";
import isEmpty from "lodash-es/isEmpty.js";
import isNil from "lodash-es/isNil.js";
import isUndefined from "lodash-es/isUndefined.js";
import difference from "lodash-es/difference.js";
import round from "lodash-es/round.js";
import uniq from "lodash-es/uniq.js";
import uniqBy from "lodash-es/uniqBy.js";
import isPlainObject from "lodash-es/isPlainObject.js";
import flattenDeep from "lodash-es/flattenDeep.js";
import intersection from "lodash-es/intersection.js";
import compact from "lodash-es/compact.js";
import isEqual from "lodash-es/isEqual.js";
import rangeRight from "lodash-es/rangeRight.js";
import { validateId } from "./validate-identifier.js";
import { normalise, isURL } from "./lib.js";
import { toRaw } from "vue";
import { getContextDefinition } from "./contexts.js";

const entityDateCreatedProperty = "hasCreationDate";
const entityDateUpdatedProperty = "hasModificationDate";

const structuredClone = function (data) {
    return window.structuredClone(toRaw(data));
};

/**
 * @class
 *
 * @name CrateManager
 * @param {crate} - an RO Crate to handle
 * @description A class to work with RO-Crates
 */
export class CrateManager {
    constructor({ crate, pm, context = undefined, entityTimestamps = false }) {
        // the crate
        this.crate = undefined;

        // the profile manager - if you've set a profile
        this.pm = pm;

        // entity reverse associations
        this.reverse = {};

        // number of entities in the graph
        this.graphLength = undefined;

        // shortcuts to the root descriptor and dataset
        this.rootDescriptor = undefined;
        this.rootDataset = undefined;

        // the mapping of entity id to index in this.crate['@graph]
        this.entityIdIndex = {};

        // reference to a context that has been provided
        //  this takes precedence over anything else
        this.providedContext = undefined;

        // otherwise, Crate Manager will manage the context
        this.contextDefinitions = undefined;
        this.localContext = {};

        // entity types in the crate - for browse entities; filter by type
        this.entityTypes = {};

        // should entity created and updated timestamps be automatically managed / added
        this.entityTimestamps = entityTimestamps;

        // keep track of blank nodes for when we mint new ones
        // this.blankNodes = [ '_:Relationship1', '_:Relationship2', '_:CreateAction1', '_:CreateAction2', ... ]
        this.blankNodes = [];

        // entity core properties
        this.coreProperties = ["@id", "@type", "@reverse", "name"];
        this.errors = {
            hasError: false,
            init: {
                description: `Errors encountered on crate load. These need to be fixed manually.`,
                messages: [],
            },
            missingIdentifier: {
                description: `The entity does not have an identifier (@id).`,
                entity: [],
            },
            missingTypeDefinition: {
                description: `The entity does not have a defined type (@type).`,
                entity: [],
            },
            invalidIdentifier: {
                description: `The entity identifier (@id) is not valid. See https://github.com/describo/crate-builder-component/blob/master/README.identifiers.md for more information`,
                entity: [],
            },
        };
        this.warnings = {
            hasWarning: false,
            invalidIdentifier: {
                description: `The entity identifier (@id) has spaces in it that should be encoded. Describo will do this to pass the validate test but the data must be corrected manually.`,
                entity: [],
            },
        };
        const t0 = performance.now();

        // verify some basic structural elements exist
        if (!crate["@context"]) {
            this.__setError("init", `The crate file does not have a '@context'.`);
            return;
        }
        if (!crate["@graph"] || !isArray(crate["@graph"])) {
            this.__setError("init", `The crate file does not have '@graph' or it's not an array.`);
            return;
        }
        const graphLength = crate["@graph"].length;
        for (let i = 0; i &lt; graphLength; i++) {
            const entity = crate["@graph"][i];

            // if the entity is empty - ignore it
            if (isPlainObject(entity) &amp;&amp; isEmpty(entity)) continue;

            // if the entity is the root descriptor, store it
            if (entity["@id"] === "ro-crate-metadata.json") {
                this.rootDescriptor = entity;
            }

            // if the entity is the root dataset, store it and ensure the @id is correct
            if (entity["@id"] === this.rootDescriptor?.about?.["@id"]) {
                this.rootDataset = entity;

                // set the root dataset @id to './'
                this.rootDataset["@id"] = "./";
                this.rootDescriptor.about["@id"] = "./";
            }

            // validate each entity
            if (!("@id" in entity)) {
                this.__setError("missingIdentifier", entity);
                continue;
            }
            if (!("@type" in entity)) {
                this.__setError("missingTypeDefinition", entity);
                continue;
            }

            //  does the id have spaces in it? log a warning
            if (entity["@id"].match(/\s+/)) {
                this.__setWarning("invalidIdentifier", entity);
            }

            // is it a valid identifier?
            let { isValid } = validateId({ id: entity["@id"], type: entity["@type"] });
            if (!isValid) {
                this.__setError("invalidIdentifier", entity);
                continue;
            }

            // is it a blank node? Store it if it is
            if (entity["@id"].match(/^_:/)) {
                this.blankNodes.push(entity["@id"]);
            }
            // create the id to index reference
            crate["@graph"][i] = normalise(entity, i);
            this.entityIdIndex[entity["@id"]] = i;
            this.reverse[entity["@id"]] = {};

            // store the entity type for lookups by type
            this.__storeEntityType(entity);
        }

        // if we get to here and haven't located a root descriptor; bail - this
        //  crate is borked
        if (!this.rootDescriptor) {
            this.__setError(
                "init",
                `This crate is invalid. A root descriptor can not been identified.`
            );
            return;
        }

        // if we don't have a root dataset, then we need to make another pass to find it
        //
        //  this will happen if the root dataset comes before the root descriptor in the
        //  graph
        if (!this.rootDataset) {
            for (let i = 0; i &lt; graphLength; i++) {
                const entity = crate["@graph"][i];

                // if the entity is the root dataset, store it and ensure the @id is correct
                if (
                    [
                        this.rootDescriptor.about["@id"],
                        this.rootDescriptor.about?.[0]?.["@id"],
                    ].includes(entity["@id"])
                ) {
                    this.rootDataset = entity;

                    // set the root dataset @id to './'
                    this.rootDataset["@id"] = "./";
                    this.rootDescriptor.about["@id"] = "./";
                    break;
                }
            }
        }

        // if we still haven't identified a root dataset then the crate is badly broken
        if (!this.rootDataset) {
            this.__setError("init", `This crate is invalid. A root dataset can not be identified.`);
            return;
        }

        // one final iteration over the crate to record the reverse links
        //  and make sure every property looks sensible
        for (let i = 0; i &lt; graphLength; i++) {
            let entity = crate["@graph"][i];

            for (let property of Object.keys(entity)) {
                // if an entity does not have a name, set the @id as the name
                if (!entity.name) entity.name = entity["@id"];
                if (this.coreProperties.includes(property)) continue;

                entity[property] = [].concat(entity[property]);

                // ensure we don't have any empty properties
                entity[property] = entity[property].filter((i) => !isEmpty(i) &amp;&amp; !isNil(i));

                // now find the linked entities and populate the reverse links array
                entity[property].forEach((instance) => {
                    if (instance?.["@id"] &amp;&amp; this.reverse[instance["@id"]]) {
                        if (!this.reverse[instance["@id"]][property]) {
                            this.reverse[instance["@id"]][property] = [];
                        }

                        let links = this.reverse[instance["@id"]][property].map((l) => l["@id"]);
                        if (!links.includes(entity["@id"])) {
                            this.reverse[instance["@id"]][property].push({ "@id": entity["@id"] });
                        }
                    }
                });
            }
        }

        if (this.errors.hasError) {
            return;
        }

        // looks good - let's save some things
        this.crate = crate;
        this.graphLength = graphLength;

        // assemble all the definitions for use managing the local context
        this.contextDefinitions = this.__collectAllDefinitions(
            this.__normaliseContext(crate["@context"])
        );
        if (context) {
            // if we're given a context, store it for use later
            this.providedContext = structuredClone(this.__normaliseContext(context));
        }

        const t1 = performance.now();
        console.debug(`Crate load: ${round(t1 - t0, 1)}ms`);
    }

    /** Get the context
     * @returns the crate context
     */
    getContext() {
        if (this.providedContext) {
            return structuredClone(this.providedContext);
        } else {
            let context = this.crate["@context"];
            context = this.__normaliseContext(context);
            if (!isEmpty(this.localContext)) {
                context = [...context, this.localContext];
                context = this.__normaliseContext(context);
            }
            return structuredClone(context);
        }
    }

    /**
     * Set the context
     *
     * @description This is equivalent to a profile author setting a context. It gets
     *   used as is and data updates going forward do not get dealth with.
     * @param {*} context
     */
    setContext(context) {
        this.providedContext = this.__normaliseContext(context);
    }

    /**
     * Set a profile
     * @description  CrateManager can set reverse associations if defined in a profile.
     *
     * */
    setProfileManager(pm) {
        this.pm = pm;
    }

    /**
     * Get the root dataset
     *
     * @returns the root dataset entity
     * @example

const cm = new CrateManager({ crate })
let rd = cm.getRootDataset()

     */
    getRootDataset() {
        let rootDataset = structuredClone(this.rootDataset);
        rootDataset["@reverse"] = structuredClone(this.reverse[rootDataset["@id"]]);
        return rootDataset;
    }

    /**
     * Get an entity
     *
     * @param {Object} options
     * @param {string} options.id - the id of the entity to get
     * @param {boolean} options.stub - if true, only the `@id, @type and name` prop's will be returned. That is,
     *                   you get a stub entry not the complete entity data.
     * @param {boolean} options.link - if true, all the associated entities are filled out as stubs
     * @param {boolean} options.materialise - if true, the entity will be created if it doesn't exist (consider
     *                  when URL's point outside the crate, in this case, they will be created as entities inside it)
     * @returns the entity
     *
     * @example

const cm = new CrateManager({ crate })

// get the full entity
let rd = cm.getEntity({ id: './' })

// return a stub entry
rd = cm.getEntity({ id: './', stub: true })

     */
    getEntity({ id, stub = false, link = true, materialise = true }) {
        if (!id) throw new Error(`An id must be provided`);
        let indexRef = this.entityIdIndex[id];
        let entity = structuredClone(this.crate["@graph"][indexRef]);

        // encode the id
        id = encodeURI(id);

        // id's pointing outside the crate won't resolve so we
        //   'materialise' them here
        if (!entity &amp;&amp; materialise) return this.__materialiseEntity({ id });
        if (!entity &amp;&amp; !materialise) return undefined;

        entity["@reverse"] = structuredClone(this.reverse[entity["@id"]]) ?? {};
        if (stub) {
            return { "@id": entity["@id"], "@type": entity["@type"], name: entity.name };
        }
        if (link) {
            for (let property of Object.keys(entity)) {
                if (this.coreProperties.includes(property)) continue;
                entity[property] = entity[property].map((value) => {
                    if (value?.["@id"]) {
                        return this.getEntity({ id: value["@id"], stub: true });
                    }
                    return value;
                });
            }
        }
        return entity;
    }

    /**
     *  Get Entity Types
     *
     * @returns an array of entity types, sorted, found in the crate
     */
    getEntityTypes() {
        return Object.keys(this.entityTypes).sort();
    }

    /**
     *@generator
     *
     * @param {Object} params
     * @param {Number} params.limit - how many entities to return
     * @param {string} params.query - a string to match against @id, @type and name
     * @param {string} params.type -  a string to match against @type
     * @yields {entity}
     * @example

const cm = new CrateManager({crate})
let entities = cm.getEntities()

for (let entity of entities) {
    ...
}

To get an array just spread the return
let entities = [ ...cm.getEntities() ]

// query @id, @type and name
entities = cm.getEntities({ query: 'person' })

// query @id, @type and name for entites of type Person
entities = cm.getEntities({ query: 'person', type: 'Person' })

// query @id, @type and name for entites of type Person - limit 10 matches
entities = cm.getEntities({ query: 'person', type: 'Person', limit: 10 })

     */
    *getEntities(params = { limit: undefined, query: undefined, type: undefined }) {
        let { limit, query, type } = params;

        if (!isString(query) &amp;&amp; !isUndefined(query)) {
            throw new Error(`query must be a string`);
        }
        if (!isString(type) &amp;&amp; !isUndefined(type)) {
            throw new Error(`type must be a string`);
        }
        if (query) {
            query = query.toLowerCase();
        }
        if (type === "ANY") type = undefined;

        let count = 0;
        for (let i = 0; i &lt; this.graphLength; i++) {
            let entity = this.crate["@graph"][i];
            if (!entity) continue;
            if (query || type) {
                let eid = entity["@id"].toLowerCase();
                let etype = isArray(entity["@type"])
                    ? entity["@type"].join(", ").toLowerCase()
                    : entity["@type"].toLowerCase();
                let name = entity.name.toLowerCase();
                if (type &amp;&amp; !query) {
                    type = type.toLowerCase();
                    if (etype.match(type)) {
                        yield structuredClone(entity);
                        count += 1;
                    }
                } else if (query &amp;&amp; !type) {
                    if (eid.match(query) || name.match(query)) {
                        yield structuredClone(entity);
                        count += 1;
                    }
                } else if (query &amp;&amp; type) {
                    type = type.toLowerCase();
                    if (etype.match(type) &amp;&amp; (eid.match(query) || name.match(query))) {
                        yield structuredClone(entity);
                        count += 1;
                    }
                }
            } else {
                if (entity) {
                    yield structuredClone(entity);
                    count += 1;
                }
            }

            if (limit &amp;&amp; count === limit) return;
        }
    }

    /**
     *
     * locateEntity
     *
     * @description Given a set of id's, find the entity or entities that link to all of them.
     *  This is really for finding grouping type entities like Relationships and Actions so that
     *  you can augment their description.
     *  @param { object } params
     *  @param { array } params.entityIds - an array of entity id's that are linked to from another entity
     *  @param { boolean } params.strict - if true return entities that have exactly entityIds linked. If false,
     *                          return entities that have at least entityIds linked
     *  @returns [] entities matching or undefined
     */

    locateEntity({ entityIds, strict = true }) {
        // encode entityIds
        entityIds = entityIds.map((eid) => encodeURI(eid));

        // console.log(entityIds);
        // get one id and use that to resolve what it links to
        let entity = this.getEntity({ id: entityIds[0], materialise: false });

        //   if it doesn't link to anything then there's no match
        if (!entity) return undefined;

        // if it does, for each match walk the entity forward and find out what it links to
        // console.log(entity, this.reverse);
        let thisEntityLinksTo = this.reverse[entity["@id"]];

        let matches = {};
        for (let property of Object.keys(thisEntityLinksTo)) {
            for (let e of thisEntityLinksTo[property]) {
                matches[e["@id"]] = [];
            }
        }

        let entityMatches = [];

        for (let entityId of Object.keys(matches)) {
            let entity = this.getEntity({ id: entityId });
            for (let property of Object.keys(entity)) {
                if (this.coreProperties.includes(property)) continue;
                for (let instance of entity[property]) {
                    if (instance?.["@id"]) matches[entityId].push(instance["@id"]);
                }
            }
            if (strict) {
                // if strict is true then check if the linked entities match exactly
                if (isEqual(matches[entityId].sort(), entityIds.sort())) entityMatches.push(entity);
            } else {
                // otherwise, check that entityIds is a subset of matches
                if (intersection(matches[entityId], entityIds).length === entityIds.length) {
                    entityMatches.push(entity);
                }
            }
        }
        return entityMatches;
    }

    /**
     * resolveLinkedEntities
     *
     * Given an entity and a profile, if the entity matches a resolve configuration
     *   this method will populate the entities linked from the resolve properties
     *   defined in the profile.
     *
     * @param {Object} entity
     * @param {Object} profile
     *
     * @returns an array of associations
     * @example

// given an entity
let entity = {
    "@id": "#createAction1",
    "@type": ["CreateAction"],
    name: "A very long named create action to demonstrate what happens with display of long names",
    object: { "@id": "#person2" },
    participant: { "@id": "#participant1" },
    agent: { "@id": "#agent1" },
};

// and a profile with a resolve configuration
let profile = {
    ...
    resolve: [
        {
            types: [ 'Relationship', 'Related' ],
            properties: [ 'source', 'target' ]
        },
        {
            types: [ 'CreateAction', 'EditAction' ],
            properties: [ 'object', 'participant', 'agent' ]
        }
    ]
    ...
}

// get a list of the associated entities
console.log(cm.resolveLinkedEntityAssociations({ entity, profile }))


associations === [
  {
    property: 'object',
    '@id': '#person2',
    '@type': [ 'Thing' ],
    name: '#person2'
  },
  {
    property: 'participant',
    '@id': '#participant1',
    '@type': [ 'Thing' ],
    name: '#participant1'
  },
  {
    property: 'agent',
    '@id': '#agent1',
    '@type': [ 'Thing' ],
    name: '#agent1'
  }
]

     */
    resolveLinkedEntityAssociations({ entity, profile }) {
        if (!profile?.resolve) return [];
        let resolveConfiguration = profile.resolve;
        const resolvers = {};
        resolveConfiguration.forEach((c) => {
            c.types.forEach((type) => {
                resolvers[type] = c.properties;
            });
        });

        // does the entity @type overlap with a resolve configuration?
        const match = intersection(Object.keys(resolvers), entity["@type"]);
        if (!match.length) {
            // the current entity does match a resolve definition
            return [];
        }

        // what properties need to be resolved?
        const propertiesToResolve = flattenDeep(match.map((type) => resolvers[type]));

        let associations = [];
        for (let property of Object.keys(entity)) {
            // skip core prop's and any prop not specifically configured to resolve
            if (this.coreProperties.includes(property)) continue;
            if (!propertiesToResolve.includes(property)) continue;

            // resolve away
            let values = [].concat(entity[property]);
            values.forEach((value) => {
                if (!("@id" in value)) return value;
                associations.push({
                    property,
                    ...this.getEntity({ id: value["@id"], stub: true }),
                });
            });
        }
        return associations;
    }

    /**
     * Add an entity to the graph
     *
     * @param {Object} entity - an entity definition to add to the crate
     * @description
     *  The entity must have '@id' and '@type' defined.
     * @returns the entity
     * @example

const cm = new CrateManager({ crate })
let entity = {
    "@id": '#e1',
    "@type": "Person",
    name: 'person1',
};
let r = cm.addEntity(entity);

     */
    addEntity(entity) {
        if (!("@id" in entity)) {
            throw new Error(`You can't add an entity without an identifier: '@id'.`);
        }
        if (!("@type" in entity)) {
            throw new Error(`You can't add an entity without defining the type : '@type'.`);
        }

        const e = structuredClone(entity);
        entity = normalise(e, this.graphLength);
        entity = this.__confirmNoClash({ entity });
        if (!entity) {
            entity = normalise(e, this.graphLength);
            return this.getEntity({ id: entity["@id"] });
        }

        // set all properties, other than core props, to array
        for (let property of Object.keys(entity)) {
            if (this.coreProperties.includes(property)) continue;

            // ensure it's an array
            entity[property] = [].concat(entity[property]);

            // then filter out empty properties with empty strings
            entity[property] = entity[property].filter((p) => p !== "");

            // remove empty properties
            if (!entity[property].length) delete entity[property];
        }

        // manage timestamps
        if (this.entityTimestamps) {
            entity[entityDateCreatedProperty] = [new Date().toISOString()];
            entity[entityDateUpdatedProperty] = [new Date().toISOString()];
        }

        // push it into the graph
        this.crate["@graph"].push(entity);

        // create the index and reverse lookup entries
        this.graphLength = this.crate["@graph"].length;
        this.entityIdIndex[entity["@id"]] = this.graphLength - 1;
        this.reverse[entity["@id"]] = {};
        this.__storeEntityType(entity);

        return entity;
    }

    /**
     * Add an entity with a blank node id ('_:...') to the graph.
     *
     * @description Use this when you want to add a non contextual entity to the graph. In thoses
     *   cases providing an @id and name don't really make sense even though those properties are still required
     *   therefore this method simplifies the process of adding those entity types. For example,
     *   Actions (e.g. CreateAction), Relationships, GeoShape, GeoCoordinates etc
     *
     * @param {string} type - the entity type to configure for the new entity
     * @returns the entity
     * @example

const cm = new CrateManager({ crate })
let r = cm.addBlankNode('Relationship);

r === {
    '@id': '_:Relationship1',
    '@type': [ 'Relationship' ],
    name: '_:Relationship1'
}

     */
    addBlankNode(type) {
        let blankNodeTypeMatches = this.blankNodes.filter((n) => n.match(type));
        const id = `_:${type}${blankNodeTypeMatches.length + 1}`;
        this.blankNodes.push(id);
        let entity = {
            "@id": id,
            "@type": type,
            name: id,
        };
        return this.addEntity(entity);
    }

    /**
     * Add files or folders - use addFile or addFolder in preference to this
     *
     * @description This is a helper method specifically for adding files and folders in the crate. This method
     *   will add the intermediate paths as 'Datasets' (as per the spec) and link everything via the hasPart
     *   property as required. It is assumed that the path is relative to the root of the folder.
     *
     * @param {object} params
     * @param {string} params.path - a file or folder path
     * @param {string} params.type - the type of thing being added - File or Dataset
     * @returns the entity
     * @example

const cm = new CrateManager({ crate })
let r = cm.addFileOrFolder('/a/b/c/file.txt);
     */
    addFileOrFolder({ path, type = "File" }) {
        if (!["File", "Dataset"].includes(type)) {
            throw new Error(`'addFileOrFolder' type must be File or Dataset`);
        }

        // ensure folders end in '/'
        if (type === "Dataset" &amp;&amp; !path.match(/.*\/$/)) {
            path = `${path}/`;
        }

        // remove initial slash if there is one
        if (path.match(/^\//)) {
            path = path.substring(1);
        }

        //  create the file path as individual datasets before joining
        //   the file into the right place
        let paths = path.split("/").slice(0, -1);
        let i = 0;
        paths = paths.map((path) => {
            let entity = {
                "@id": i > 0 ? `${paths.slice(0, i).join("/")}/${path}/` : `${path}/`,
                "@type": ["Dataset"],
                name: i > 0 ? `${paths.slice(0, i).join("/")}/${path}/` : `${path}/`,
            };
            entity = this.addEntity(entity);
            i += 1;
            return entity;
        });
        i = 0;
        for (let path of paths) {
            if (i === 0) {
                this.linkEntity({
                    id: "./",
                    property: "hasPart",
                    value: { "@id": path["@id"] },
                });
            } else {
                this.linkEntity({
                    id: paths[i - 1]["@id"],
                    property: "hasPart",
                    value: { "@id": path["@id"] },
                });
            }
            i += 1;
        }

        let entity = {
            "@id": encodeURI(path),
            "@type": [type],
            name: path,
        };
        const sourceEntity = this.getEntity({
            id: paths.length ? paths.slice(-1)[0]["@id"] : "./",
            stub: true,
        });
        this.ingestAndLink({
            id: sourceEntity["@id"],
            property: "hasPart",
            json: entity,
        });
        return this.getEntity({ id: entity["@id"], stub: true });
    }

    /**
     * Add file
     *
     * @description This is a helper method specifically for adding files to the crate. This method
     *   will add the intermediate paths as 'Datasets' (as per the spec) and link everything via the hasPart
     *   property as required. It is assumed that the path is relative to the root of the folder.
     *
     * @param {string} path - a file path to add - ensure the file path is relative to the folder root
     * @returns the entity
     * @example

const cm = new CrateManager({ crate })
let r = cm.addFile('/a/b/c/file.txt);
     */
    addFile(path) {
        return this.addFileOrFolder({ path, type: "File" });
    }

    /**
     * Add folder
     *
     * @description This is a helper method specifically for adding folders to the crate. This method
     *   will add the intermediate paths as 'Datasets' (as per the spec) and link everything via the hasPart
     *   property as required. It is assumed that the path is relative to the root of the folder.
     *
     * @param {string} path - a folder path to add - ensure the folder path is relative to the folder root
     * @returns the entity
     * @example

const cm = new CrateManager({ crate })
let r = cm.addFolder('/a/b/c);
     */
    addFolder(path) {
        return this.addFileOrFolder({ path, type: "Dataset" });
    }

    /**
     * Delete an entity
     *
     * @param {Object} options
     * @param {string} options.id - the id of the entity to delete from the crate
     *
     * @returns true if successful
     * @example

const cm = new CrateManager({ crate })
cm.deleteEntity({ id: '#e1' })

     */
    deleteEntity({ id }) {
        if (!id) throw new Error(`'deleteEntity' requires 'id' to be defined`);
        if ([this.rootDescriptor["@id"], this.rootDataset["@id"]].includes(id)) {
            throw new Error(`You can't delete the root dataset or the root descriptor.`);
        }

        const indexRef = this.entityIdIndex[id];
        const entity = this.crate["@graph"][indexRef];
        this.__removeEntityType(entity);

        // get the entity, find what it links to and remove it from the reverse of those linkages
        for (let [property, instances] of Object.entries(entity)) {
            if (this.coreProperties.includes(property)) continue;
            for (let instance of instances) {
                if (instance?.["@id"]) {
                    // console.log(instance["@id"], this.reverse[instance["@id"]]);
                    this.reverse[instance["@id"]][property] = this.reverse[instance["@id"]][
                        property
                    ].filter((i) => i["@id"] !== id);

                    // remove the property if it's empty
                    if (!this.reverse[instance["@id"]][property].length) {
                        delete this.reverse[instance["@id"]][property];
                    }
                }
            }
        }

        // now do the same by walking the reverse links from this entity
        for (let [property, instances] of Object.entries(this.reverse[entity["@id"]])) {
            if (this.coreProperties.includes(property)) continue;
            for (let instance of instances) {
                if (instance?.["@id"]) {
                    let linkIndexRef = this.entityIdIndex[instance["@id"]];
                    let linkEntity = this.crate["@graph"][linkIndexRef];
                    linkEntity[property] = linkEntity[property].filter((i) => i["@id"] !== id);

                    // remove the property if it's empty
                    if (!linkEntity[property].length) {
                        delete linkEntity[property];
                    }
                }
            }
        }

        delete this.entityIdIndex[id];
        delete this.reverse[id];
        this.crate["@graph"][indexRef] = undefined;

        return true;
    }

    /**
     * Set a property on an entity
     *
     * @param {Object} options
     * @param {options.id} options.id - the id of the entity to add the property to
     * @param {options.property } options.property - the property to add
     * @param {options.value} options.value - the data to add to that property. Can be string or object with '@id'
     * @returns true if successful
     * @example

const cm = new CrateManager({ crate })
const authorId = chance.url();

//  setting an object reference
cm.setProperty({ id: "./", property: "author", value: { "@id": authorId } });

//  setting a text string
cm.setProperty({ id: "./", property: "author", value: "text" });

//  setting a number
cm.setProperty({ id: "./", property: "author", value: 3 });

     */
    setProperty({ id, property, propertyId, value }) {
        if (this.coreProperties.includes(property)) {
            throw new Error(`This method does not operate on ${this.coreProperties.join(", ")}`);
        }
        if (!id) throw new Error(`'setProperty' requires 'id' to be defined`);
        if (!property) throw new Error(`setProperty' requires 'property' to be defined`);
        if (value !== false &amp;&amp; !value)
            throw new Error(`'setProperty' requires 'value' to be defined`);

        //  just don't set an empty object on a property
        if (isPlainObject(value) &amp;&amp; isEmpty(value)) return;

        const indexRef = this.entityIdIndex[id];
        const entity = this.crate["@graph"][indexRef];
        if (!(property in entity)) {
            entity[property] = [];
        }
        // validate the value's shape - v. important
        if (isString(value) || isNumber(value) || isBoolean(value)) {
            entity[property].push(value);
        } else if (isPlainObject(value) &amp;&amp; "@id" in value) {
            // value makes sense
            // but make sure it's only the id and not the whole entity
            value = { "@id": value["@id"] };

            // and don't add duplicates
            let ids = entity[property].filter((v) => v?.["@id"]).map((v) => v["@id"]);
            if (!ids.includes(value["@id"])) entity[property].push(value);

            // and add a @reverse link
            this.__addReverse({ id, property, value });
        } else {
            // value doesn't make sense - bail
            throw new Error(`value must be a string, number, boolean or object with '@id'`);
        }
        this.__updateContext({ name: property, id: propertyId });

        // manage timestamps
        if (this.entityTimestamps) {
            entity[entityDateUpdatedProperty] = [new Date().toISOString()];
        }
        return true;
    }

    /**
     * Update a property on an entity
     *
     * @param {Object} options
     * @param {string} options.id - the id of the entity to add the property to
     * @param {string} options.property - the property to add
     * @param {string} options.idx - the idx of the property array to update
     * @param {string} options.value - the data to add to that property, string or object with '@id'
     * @example

const cm = new CrateManager({ crate })
cm.updateProperty({ id: "./", property: "@id", value: "something else" });
cm.updateProperty({ id: "./", property: "author", idx: 1, value: "new" });

     */
    updateProperty({ id, property, idx, value }) {
        if (!id) throw new Error(`'setProperty' requires 'id' to be defined`);
        if (!property) throw new Error(`setProperty' requires 'property' to be defined`);
        if (value !== false &amp;&amp; !value)
            throw new Error(`'setProperty' requires 'value' to be defined`);

        //  just don't set an empty object on a property
        if (isPlainObject(value) &amp;&amp; isEmpty(value)) return;

        let indexRef = this.entityIdIndex[id];
        if (!indexRef) return `No such entity: ${id}`;
        const entity = this.crate["@graph"][indexRef];
        if (this.coreProperties.includes(property)) {
            if (property === "@id") {
                //  update @id
                this.__updateEntityId({ oldId: entity["@id"], newId: value });
            } else if (property === "@type") {
                //  update @type
                //   ensure it's an array first though or weird sh*t happens
                value = [].concat(value);

                //  when updating the type we first need to clear out the
                //   old types and then set the new so we end up with correct
                //   reference counts
                this.__removeEntityType(entity);
                entity["@type"] = uniq(value);
                this.__storeEntityType(entity);
            } else if (property === "name") {
                // update name
                // ensure we're setting a string value for the name property
                if (isArray(value)) value = value.join(", ");
                entity.name = value;
            }
        } else {
            if (idx !== 0 &amp;&amp; !idx) throw new Error(`setProperty' requires 'idx' to be defined`);
            entity[property][idx] = value;
        }

        // manage timestamps
        if (this.entityTimestamps) {
            entity[entityDateUpdatedProperty] = [new Date().toISOString()];
        }
        return entity;
    }

    /**
     * Delete a specific property from the entity. That is, an instance of a property.
     *
     * @param {Object}
     * @param {string} options.id - the id of the entity to remove the property value from
     * @param {string} options.property - the property
     * @param {string} options.idx - the idx of the property array to delete
     * @example

const cm = new CrateManager({ crate })
cm.deleteProperty({ id: "./", property: "author", idx: 1 });

     */
    deleteProperty({ id, property, idx }) {
        if (!id) throw new Error(`'deleteProperty' requires 'id' to be defined`);
        if (!property) throw new Error(`deleteProperty' requires 'property' to be defined`);
        if (idx !== 0 &amp;&amp; !idx) throw new Error(`deleteProperty' requires 'idx' to be defined`);

        const indexRef = this.entityIdIndex[id];
        const entity = this.crate["@graph"][indexRef];
        entity[property].splice(idx, 1);
        if (!entity[property].length) delete entity[property];

        // manage timestamps
        if (this.entityTimestamps) {
            entity[entityDateUpdatedProperty] = [new Date().toISOString()];
        }
    }

    /**
     * Delete all data attached to a property. That is, all instances.
     *
     * @param {Object}
     * @param {string} options.id - the id of the entity to remove the property value from
     * @param {string} options.property - the property
     * @example

const cm = new CrateManager({ crate })
cm.deleteAllProperties({ id: "./", property: "author" });

     */
    deleteAllProperties({ id, property }) {
        if (!id) throw new Error(`'deleteProperty' requires 'id' to be defined`);
        if (!property) throw new Error(`deleteProperty' requires 'property' to be defined`);

        const indexRef = this.entityIdIndex[id];
        const entity = this.crate["@graph"][indexRef];

        if (entity[property]?.length) {
            for (let idx of rangeRight(entity[property].length)) {
                this.deleteProperty({ id: entity["@id"], property, idx });
            }
        }
    }

    /**
     * Ingest and link a nested json object
     *
     * @param {Object} options
     * @param {string} options.id - the id of the entity to join the data into
     * @param {string} options.property - the property to join the data into
     * @param {json} options.json - the data object to join in
     * @example

const cm = new CrateManager({ crate })
let json = {
    ...,
}
cm.ingestAndLink({
    id: "./",
    property: "language",
    json,
});

     */
    ingestAndLink({ id = undefined, property = undefined, propertyId = undefined, json = {} }) {
        if (!id) throw new Error(`ingestAndLink: 'id' must be defined`);
        if (!property) throw new Error(`ingestAndLink: 'property' must be defined`);

        let flattened = this.flatten(json);
        flattened = flattened.map((entity) => {
            entity = normalise(entity, this.graphLength);
            entity = this.addEntity(entity);
            return entity;
        });

        this.linkEntity({ id, property, propertyId, value: { "@id": flattened[0]["@id"] } });

        //  go through and set all of the reverse links
        for (let entity of flattened) {
            for (let prop of Object.keys(entity)) {
                if (this.coreProperties.includes(prop)) continue;
                entity[prop].forEach((instance) => {
                    if (instance?.["@id"]) {
                        this.__addReverse({ id: entity["@id"], property: prop, value: instance });
                    }
                });
            }
        }
    }

    /**
     * Flatten a nested json object to an array
     *
     * @param {Object} json - a potentially nested data blob to flatten into array
     * @returns an array of objects
     * @example

const cm = new CrateManager({ crate })
let json = {
    ...,
}
let arrayOfObjects = cm.flatten(json)

     */
    flatten(json) {
        if (!isPlainObject(json)) {
            throw new Error(`flatten only takes an object.`);
        }
        json = structuredClone(toRaw(json));
        let flattened = [];
        flattened.push(json);
        for (let property of Object.keys(json)) {
            if (["@id", "@type", "name"].includes(property)) continue;
            if (!isArray(json[property])) json[property] = [json[property]];
            json[property].forEach((instance) => {
                if (isPlainObject(instance)) flattened.push(this.flatten(instance));
            });
            json[property] = json[property].map((instance) => {
                if (isPlainObject(instance)) return { "@id": instance["@id"] };
                return instance;
            });
        }
        return flattenDeep(flattened).map((e) => e);
    }

    /**
     * Link two entities
     *
     * @description Link two entities via a property. If there is a profile defined
     *      and it has reverse associations, then they will be added.
     * @param {Object} options
     * @param {string} options.id - the id of the entity to add the association to
     * @param {string} options.property - the property to add the association to
     * @param {object} options.value - an object with '@id' defining the association to create
     * @example

const cm = new CrateManager({ crate })
cm.linkEntity({ id: './', property: 'author', value: { '@id': '#e1' }})

     **/
    linkEntity({ id = undefined, property = undefined, propertyId = undefined, value }) {
        if (!id) throw new Error(`'linkEntity' requires 'id' to be defined`);
        if (!property) throw new Error(`'linkEntity' requires 'property' to be defined`);
        if (!value) throw new Error(`'linkEntity' requires 'value' to be defined`);
        if (!isPlainObject(value) || !value["@id"]) {
            throw new Error(`value must be an object with '@id' defined`);
        }
        this.setProperty({ id, property, propertyId, value });

        // set inverse association if required
        const associations = this.pm?.getPropertyAssociations() ?? {};
        if (associations[property]) {
            let inverse = associations[property];
            this.setProperty({
                id: value["@id"],
                property: inverse.property,
                propertyId: inverse.propertyId,
                value: { "@id": id },
            });
        }
    }

    /**
     * Unlink two entities
     *
     * @description Remove an association between two entities. If there is a profile defined
     *      and it has reverse associations, then they will be removed as well.
     * @param {Object} options
     * @param {string} options.id - the id of the entity to remove the association from
     * @param {string} options.property - the property containing the association
     * @param {object} options.value - an object with '@id' defining the association to remove
     * @example

const cm = new CrateManager({ crate })
const cm = new CrateManager({ crate })
cm.unlinkEntity({ id: './', property: 'author', value: { '@id': '#e1' }})

     **/
    unlinkEntity({ id = undefined, property = undefined, value = undefined, stop = false }) {
        if (!id) throw new Error(`'unlinkEntity' requires 'id' to be defined`);
        if (!property) throw new Error(`'unlinkEntity' requires 'property' to be defined`);
        if (!value) throw new Error(`'unlinkEntity' requires 'value' to be defined`);
        if (!isPlainObject(value) || !value["@id"]) {
            throw new Error(`value must be an object with '@id' defined`);
        }

        // console.log("START", id, property, value["@id"]);
        // get the source entity
        let indexRef = this.entityIdIndex[id];
        let entity = this.crate["@graph"][indexRef];
        // console.log("SOURCE ENTITY BEFORE ", entity);

        // and remove the linked entity from the specified property
        entity[property] = entity[property].filter((v) => {
            if (v?.["@id"] &amp;&amp; v["@id"] === value["@id"]) {
                // do nothing - we don't want it
            } else {
                return v;
            }
        });
        if (!entity[property].length) delete entity[property];

        // manage timestamps
        if (this.entityTimestamps) {
            entity[entityDateUpdatedProperty] = [new Date().toISOString()];
        }
        // console.log("SOURCE ENTITY AFTER", entity);

        // clean up the reverse mapping back value['@id'] -> id

        // console.log(`TARGET ENTITY BEFORE REVERSE`, this.reverse[value["@id"]]);
        // console.log();
        if (this.reverse[value["@id"]]) {
            this.reverse[value["@id"]][property] = this.reverse[value["@id"]][property].filter(
                (v) => {
                    return v["@id"] !== id;
                }
            );
            if (!this.reverse[value["@id"]][property].length)
                delete this.reverse[value["@id"]][property];
        }
        // console.log(`TARGET ENTITY AFTER REVERSE`, this.reverse[value["@id"]]);
        // remove any inverse associations
        const associations = this.pm?.getPropertyAssociations() ?? {};
        if (associations[property] &amp;&amp; !stop) {
            const inverse = associations[property];
            // console.log(inverse, value["@id"], property, id);
            this.unlinkEntity({
                id: value["@id"],
                property: inverse.property,
                value: { "@id": id },
                stop: true, // V. IMPORTANT so we don't get into an infinite loop
            });
        }
    }

    /**
     * Purge unlinked entities from the crate
     *
     * @description - clean up the graph and purge any unlinked entities including disconnected subtrees.
     * @example

const cm = new CrateManager({ crate })
cm.purgeUnlinkedEntities()

     */
    purgeUnlinkedEntities() {
        walker = walker.bind(this);
        let linkedEntities = { "ro-crate-metadata.json": true };
        let indexRef = this.entityIdIndex["ro-crate-metadata.json"];
        if (indexRef !== undefined) {
            // we first need to walk the graph from the root descriptor
            //  and assemble a list of linked entities that we get to by
            //  following forward looking associations
            let entity = this.crate["@graph"][indexRef];
            walker(entity);

            // then, we walk the entire graph and look for entities
            //   that are not already linked. When we find one, we walk
            //   it forwards to see if it links to anything already linked
            //   and if yes, then we link it
            // think things like relationships and actions that may link
            //   to enities in the graph even though they themselves are not linked to
            for (let i = 0; i &lt; this.graphLength; i++) {
                let entity = this.crate["@graph"][i];
                if (!entity) continue;
                if (!linkedEntities[entity["@id"]]) {
                    for (let property of Object.keys(entity)) {
                        if (this.coreProperties.includes(property)) continue;
                        entity[property].forEach((instance) => {
                            if (instance?.["@id"] &amp;&amp; linkedEntities[instance["@id"]]) {
                                linkedEntities[entity["@id"]] = true;
                            }
                        });
                    }
                }
            }

            // now we can remove everything we couldn't get to
            for (let i = 0; i &lt; this.graphLength; i++) {
                let entity = this.crate["@graph"][i];
                if (entity &amp;&amp; !linkedEntities[entity["@id"]]) {
                    let indexRef = this.entityIdIndex[entity["@id"]];
                    delete this.entityIdIndex[entity["@id"]];
                    delete this.reverse[entity["@id"]];
                    this.crate["@graph"][indexRef] = undefined;
                }
            }
        }
        function walker(entity) {
            linkedEntities[entity["@id"]] = true;
            for (let property of Object.keys(entity)) {
                if (this.coreProperties.includes(property)) continue;
                entity[property].forEach((instance) => {
                    if (instance?.["@id"] &amp;&amp; !linkedEntities[instance["@id"]]) {
                        let indexRef = this.entityIdIndex[instance["@id"]];
                        if (indexRef !== undefined) {
                            let entity = this.crate["@graph"][indexRef];
                            walker(entity);
                        }
                    }
                });
            }
        }
    }

    /**
     * Export the RO-Crate
     * @returns the complete ro-crate
     * @example

const cm = new CrateManager({ crate })
let crate = cm.exportCrate()

     */
    exportCrate() {
        const t0 = performance.now();
        // const crate = structuredClone(this.crate);

        let entities = this.crate["@graph"]
            .filter((e) => e)
            .map((e) => {
                e = structuredClone(e);
                e["@reverse"] = structuredClone(this.reverse[e["@id"]]);
                for (let p of Object.keys(e)) {
                    if (p === "@reverse") {
                        for (let rp of Object.keys(e["@reverse"])) {
                            if (isArray(e[p][rp]) &amp;&amp; e[p][rp].length === 1) e[p][rp] = e[p][rp][0];
                        }
                    } else {
                        if (isArray(e[p]) &amp;&amp; e[p].length === 1) e[p] = e[p][0];
                    }
                }
                return e;
            });

        const context = this.getContext();
        const crate = {
            "@context": context.length === 1 ? context[0] : context,
            "@graph": entities,
        };
        const t1 = performance.now();
        console.debug(`Crate export: ${round(t1 - t0, 1)}ms`);
        // console.log(JSON.stringify(this.crate, null, 2));
        return crate;
    }

    /**
     *
     * @param {Object} options
     * @param {String} options.id - the id of the entity to export as a template
     * @param {String} options.resolveDepth - 0 or 1. If 1, linked entities will be joined in
     * @description
     *
     * 1. If resolveDepth = 0 then the entity is returned with all associations removed
     * 2.  If resolveDepth = 1 then the entity is returned with one level of associations populated but
     *    all of their associations will be removed.
     *
     * @returns entity
     * @example

const cm = new CrateManager({ crate })
let entity = cm.exportEntityTemplate({ id: '#person' })
let entity = cm.exportEntityTemplate({ id: '#person', resolveDepth: 1 })

     */
    exportEntityTemplate({ id, resolveDepth = 0 }) {
        if (![0, 1].includes(resolveDepth)) {
            throw new Error(`resolveDepth can only be 0 or 1`);
        }
        let indexRef = this.entityIdIndex[id];
        let entity = structuredClone(this.crate["@graph"][indexRef]);

        for (let property of Object.keys(entity)) {
            if (this.coreProperties.includes(property)) continue;

            entity[property] = entity[property]
                .map((value) => {
                    if (value?.["@id"]) {
                        if (resolveDepth === 0) return undefined;
                        let linkedIndexRef = this.entityIdIndex[value["@id"]];
                        let linkedEntity = structuredClone(this.crate["@graph"][linkedIndexRef]);
                        linkedEntity = this.__removeAssociations(linkedEntity);
                        delete linkedEntity["@reverse"];
                        return linkedEntity;
                    } else {
                        return value;
                    }
                })
                .map((v) => v);
            entity[property] = compact(entity[property]);
            if (entity[property].length === 0) {
                delete entity[property];
            } else if (entity[property].length === 1) {
                entity[property] = entity[property][0];
            }
        }
        delete entity["@reverse"];
        return entity;
    }

    /**
     * getErrors
     *
     * @returns { errors }
     *
     */
    getErrors() {
        return this.errors;
    }

    /**
     * getWarnings
     *
     * @returns { warnings }
     */
    getWarnings() {
        return this.warnings;
    }

    __updateContext({ name, id }) {
        if (id &amp;&amp; !(id in this.contextDefinitions)) {
            // the property or class isn't defined in the context
            //   add it in the definitions for lookups later
            //   store it in the local context which gets joined
            //    in where required.
            this.contextDefinitions[id] = true;
            this.localContext[name] = id;
        }
    }

    /**
     * Normalise context
     *
     * @description Collapse all objects into a single object
     * @param {*} context
     * @returns context
     */
    __normaliseContext(context) {
        context = [].concat(context);
        let entries = {};
        for (let entry of context) {
            if (isPlainObject(entry)) entries = { ...entries, ...entry };
        }
        context = context.filter((e) => isString(e));
        if (!isEmpty(entries)) context = [...context, entries];
        return context;
    }
    __storeEntityType(entity) {
        // store the entity type for lookups by type
        entity["@type"].forEach((type) => {
            if (!this.entityTypes[type]) {
                this.entityTypes[type] = 1;
            } else {
                this.entityTypes[type] += 1;
            }
        });
    }
    __removeEntityType(entity) {
        // update the entity type's store
        entity["@type"].forEach((type) => {
            this.entityTypes[type] -= 1;
            if (this.entityTypes[type] === 0) delete this.entityTypes[type];
        });
    }
    __collectAllDefinitions(context) {
        let definitions = {};

        for (let entry of context) {
            if (isString(entry)) {
                // likely the ro-crate context - see if it is
                let def = getContextDefinition(entry);
                if (def) {
                    definitions = { ...definitions, ...def.definitions };
                } else {
                    definitions[entry] = true;
                }
            } else if (isPlainObject(entry)) {
                for (let e of Object.entries(entry)) {
                    definitions[e[1]] = true;
                }
            }
        }
        // console.log(definitions);
        return definitions;
    }
    __setError(error, entity) {
        let errorPath = error === "init" ? "messages" : "entity";
        this.errors[error][errorPath].push(entity);
        this.errors.hasError = true;
    }
    __setWarning(warning, entity) {
        this.warnings[warning].entity.push(entity);
        this.warnings.hasWarning = true;
    }
    __materialiseEntity({ id }) {
        return {
            "@id": id,
            "@type": isURL(id) ? ["URL"] : ["Thing"],
            name: id,
        };
    }
    __confirmNoClash({ entity, mintNewId = true }) {
        // if it looks like the root dataset - throw an error
        //  can't have multiple root datasets
        if (entity["@id"] === "./") {
            throw new Error(
                `You can't add an entity with id: './' as that will clash with the root dataset.`
            );
        }
        // if it looks like the root descriptor - throw an error
        //  can't have multiple root descriptors
        if (entity["@id"] === "ro-crate-metadata.json") {
            throw new Error(
                `You can't add an entity with id: 'ro-crate-metadata.json' as that will clash with the root descriptor.`
            );
        }

        let idx = this.entityIdIndex[entity["@id"]];

        // if there is no id clash, return the entity as is
        if (idx === undefined) return entity;

        // if the id is already used, check that the type is different
        //   if it is, change the id and return the entity for inclusion
        let entityLookup = this.crate["@graph"][idx];
        if (!difference(entityLookup?.["@type"], entity["@type"]).length) {
            return false;
        } else {
            // if get to here then there's a clash

            if (mintNewId) {
                const id = `e${this.graphLength + 1}`;
                entity["@id"] = `#${id}`;
                return entity;
            } else {
                throw new Error("That id is already used on another entity");
            }
        }
    }
    __updateEntityId({ oldId, newId }) {
        if (!oldId) throw new Error(`You must provide the id to change: oldId`);
        if (!newId) throw new Error(`You must provide the id for the change: newId`);
        // get the original entity and see if we can set this new id on it
        //  we clone the original entity as we don't want to set anything yet
        let indexRef = this.entityIdIndex[oldId];
        // console.log("ORIGINAL ENTITY", JSON.stringify(this.crate["@graph"][indexRef], null, 2));
        let entity = structuredClone(this.crate["@graph"][indexRef]);
        entity["@id"] = newId;
        entity = normalise(entity, this.graphLength);
        entity = this.__confirmNoClash({ entity, mintNewId: false });
        // console.log("NEW ENTITY", JSON.stringify(entity, null, 2));

        // get the entity using the original id and then walk the properties forward
        //  to find what it links to. For each of those, set the reverse link to the new id
        indexRef = this.entityIdIndex[oldId];
        let oe = this.crate["@graph"][indexRef];
        for (let [property, instances] of Object.entries(oe)) {
            if (this.coreProperties.includes(property)) continue;
            for (let instance of instances) {
                if (instance?.["@id"]) {
                    // console.log(
                    //     "FORWARD LINKED ENTITY BEFORE",
                    //     property,
                    //     this.reverse[instance["@id"]][property]
                    // );
                    this.reverse[instance["@id"]][property].push({ "@id": entity["@id"] });
                    this.reverse[instance["@id"]][property] = this.reverse[instance["@id"]][
                        property
                    ].filter((i) => i["@id"] !== oldId);
                    this.reverse[instance["@id"]][property] = uniqBy(
                        this.reverse[instance["@id"]][property],
                        "@id"
                    );
                    // console.log(
                    //     "FORWARD LINKED ENTITY AFTER",
                    //     property,
                    //     this.reverse[instance["@id"]][property]
                    // );
                }
            }
        }

        // walk the reverse links from this entity and update the forrward links
        // now walk the reverse links of the entity to update the references to it
        if (this.reverse[oldId]) {
            for (let [property, links] of Object.entries(this.reverse[oldId])) {
                for (let link of links) {
                    let linkIndexRef = this.entityIdIndex[link["@id"]];
                    let linkedEntity = this.crate["@graph"][linkIndexRef];

                    // console.log("REVERSE LINKED ENTITY BEFORE", property, linkedEntity[property]);
                    linkedEntity[property].push({ "@id": entity["@id"] });
                    linkedEntity[property] = linkedEntity[property].filter(
                        (i) => i["@id"] !== oldId
                    );
                    // console.log("REVERSE LINKED ENTITY AFTER", property, linkedEntity[property]);
                }
            }
        }

        // now we can update the original entity in the graph
        // set the new id on the entity itself
        indexRef = this.entityIdIndex[oldId];
        this.crate["@graph"][indexRef]["@id"] = entity["@id"];
        // console.log("NEW ENTITY IN GRAPH", JSON.stringify(this.crate["@graph"][indexRef], null, 2));

        // update the index ref's
        delete this.entityIdIndex[oldId];
        // console.log("OLDID lookup", this.entityIdIndex[oldId]);
        this.entityIdIndex[entity["@id"]] = indexRef;
        // console.log("NEWID lookup", this.entityIdIndex[entity["@id"]]);
        // console.log(
        //     "NEW ENTITY IN GRAPH",
        //     JSON.stringify(this.crate["@graph"][this.entityIdIndex[entity["@id"]]], null, 2)
        // );

        // copy the reverse associations to the new id
        //   and then remove the original reverse associations
        this.reverse[entity["@id"]] = structuredClone(this.reverse[oldId]);
        delete this.reverse[oldId];
        // console.log(
        //     "NEW ENTITY REVERSE CONNECTIONS",
        //     entity["@id"],
        //     JSON.stringify(this.reverse[entity["@id"]], null, 2)
        // );

        // console.log(JSON.stringify(this.crate["@graph"], null, 2));
        // console.log("");
        // console.log("");
        // console.log("");
        // console.log(JSON.stringify(this.reverse, null, 2));
        // console.log("");
        // console.log("");
        // console.log("");
        // console.log(JSON.stringify(this.entityIdIndex, null, 2));
    }
    __addReverse({ id, property, value }) {
        const linkIndexRef = this.entityIdIndex[value["@id"]];

        if (linkIndexRef) {
            if (!this.reverse[value["@id"]][property]) this.reverse[value["@id"]][property] = [];

            let links = this.reverse[value["@id"]][property].map((l) => l["@id"]);
            if (!links.includes(id)) {
                this.reverse[value["@id"]][property].push({ "@id": id });
            }
            // this.reverse[value["@id"]][property].push({ "@id": id });
            // this.reverse[value["@id"]][property] = uniqBy(
            //     this.reverse[value["@id"]][property],
            //     "@id"
            // );
        }
    }
    __removeAssociations(entity) {
        for (let property of Object.keys(entity)) {
            if (this.coreProperties.includes(property)) continue;
            entity[property] = entity[property].filter((value) => !value?.["@id"]);
            if (!entity[property].length) delete entity[property];
        }
        return entity;
    }
}
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.3</a> on Sat Jun 29 2024 10:17:57 GMT+1000 (Australian Eastern Standard Time) using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
